package crispr

import (
	"bytes"
	"encoding/csv"
	"fmt"
	"strings"
	"time"
)

// Exporter handles exporting guide RNAs to various formats
type Exporter struct{}

// NewExporter creates a new exporter
func NewExporter() *Exporter {
	return &Exporter{}
}

// Export exports guides to the specified format
func (e *Exporter) Export(req ExportRequest) ([]byte, error) {
	switch req.Format {
	case ExportCSV:
		return e.ExportCSV(req.Guides)
	case ExportGenBank:
		return e.ExportGenBank(req.Guides, req.Options)
	case ExportPDF:
		return e.ExportPDF(req.Guides, req.Options)
	case ExportJSON:
		return e.ExportJSON(req.Guides)
	default:
		return nil, fmt.Errorf("unsupported export format: %s", req.Format)
	}
}

// ExportCSV exports guides to CSV format
func (e *Exporter) ExportCSV(guides []GuideRNA) ([]byte, error) {
	var buf bytes.Buffer
	writer := csv.NewWriter(&buf)

	// Write header
	header := []string{
		"ID",
		"Sequence",
		"Chromosome",
		"Position",
		"Strand",
		"PAM",
		"Enzyme",
		"Doench Score",
		"Off-Target Count",
		"Off-Target Score",
		"GC Content (%)",
		"Rank Score",
		"Gene Name",
		"Exon",
	}
	if err := writer.Write(header); err != nil {
		return nil, err
	}

	// Write data
	for _, guide := range guides {
		row := []string{
			guide.ID,
			guide.Sequence,
			guide.Chromosome,
			fmt.Sprintf("%d", guide.Position),
			guide.Strand,
			guide.PAMSequence,
			string(guide.Enzyme),
			fmt.Sprintf("%.3f", guide.DoenchScore),
			fmt.Sprintf("%d", guide.OffTargetCount),
			fmt.Sprintf("%.2f", guide.OffTargetScore),
			fmt.Sprintf("%.1f", guide.GCContent),
			fmt.Sprintf("%.3f", guide.RankScore),
			guide.GeneName,
			fmt.Sprintf("%d", guide.Exon),
		}
		if err := writer.Write(row); err != nil {
			return nil, err
		}
	}

	writer.Flush()
	if err := writer.Error(); err != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}

// ExportGenBank exports guides as GenBank format (annotated plasmid)
func (e *Exporter) ExportGenBank(guides []GuideRNA, options map[string]interface{}) ([]byte, error) {
	var buf bytes.Buffer

	// Get vector backbone (default to pLentiCRISPRv2 or similar)
	vectorName := "pCRISPR-Guide"
	if name, ok := options["vector_name"].(string); ok {
		vectorName = name
	}

	// GenBank header
	buf.WriteString(fmt.Sprintf("LOCUS       %-16s %d bp    DNA     circular SYN %s\n",
		vectorName, 0, time.Now().Format("02-JAN-2006")))
	buf.WriteString("DEFINITION  CRISPR guide RNA expression vector\n")
	buf.WriteString("ACCESSION   .\n")
	buf.WriteString("VERSION     .\n")
	buf.WriteString("KEYWORDS    .\n")
	buf.WriteString("SOURCE      synthetic DNA construct\n")
	buf.WriteString("  ORGANISM  synthetic DNA construct\n")
	buf.WriteString("FEATURES             Location/Qualifiers\n")

	// Add each guide as a feature
	for i, guide := range guides {
		buf.WriteString(fmt.Sprintf("     misc_feature    %d..%d\n", i*100+1, i*100+20))
		buf.WriteString(fmt.Sprintf("                     /label=\"guide_%d\"\n", i+1))
		buf.WriteString(fmt.Sprintf("                     /note=\"sequence: %s\"\n", guide.Sequence))
		buf.WriteString(fmt.Sprintf("                     /note=\"doench_score: %.3f\"\n", guide.DoenchScore))
		buf.WriteString(fmt.Sprintf("                     /note=\"off_targets: %d\"\n", guide.OffTargetCount))
		buf.WriteString(fmt.Sprintf("                     /note=\"target: %s:%d\"\n", guide.Chromosome, guide.Position))
	}

	buf.WriteString("ORIGIN\n")

	// Add sequences in GenBank format (60bp per line, numbered)
	for i, guide := range guides {
		seq := strings.ToLower(guide.Sequence)
		buf.WriteString(fmt.Sprintf("%9d %s\n", i*20+1, e.formatSequenceLine(seq)))
	}

	buf.WriteString("//\n")

	return buf.Bytes(), nil
}

// formatSequenceLine formats a sequence line for GenBank (groups of 10bp)
func (e *Exporter) formatSequenceLine(seq string) string {
	var parts []string
	for i := 0; i < len(seq); i += 10 {
		end := i + 10
		if end > len(seq) {
			end = len(seq)
		}
		parts = append(parts, seq[i:end])
	}
	return strings.Join(parts, " ")
}

// ExportPDF exports guides as PDF report
func (e *Exporter) ExportPDF(guides []GuideRNA, options map[string]interface{}) ([]byte, error) {
	// For PDF generation, would use a library like gofpdf or chromedp
	// Here we create a simple text-based report that could be converted to PDF

	var buf bytes.Buffer

	// Title
	buf.WriteString("═══════════════════════════════════════════════════════════════\n")
	buf.WriteString("              CRISPR GUIDE RNA DESIGN REPORT\n")
	buf.WriteString("                   Generated by GenomeVedic\n")
	buf.WriteString(fmt.Sprintf("                   Date: %s\n", time.Now().Format("2006-01-02 15:04:05")))
	buf.WriteString("═══════════════════════════════════════════════════════════════\n\n")

	// Summary
	buf.WriteString("SUMMARY\n")
	buf.WriteString("───────────────────────────────────────────────────────────────\n")
	buf.WriteString(fmt.Sprintf("Total Guides: %d\n", len(guides)))

	if len(guides) > 0 {
		avgDoench := 0.0
		avgOffTarget := 0.0
		for _, g := range guides {
			avgDoench += g.DoenchScore
			avgOffTarget += float64(g.OffTargetCount)
		}
		avgDoench /= float64(len(guides))
		avgOffTarget /= float64(len(guides))

		buf.WriteString(fmt.Sprintf("Average Doench Score: %.3f\n", avgDoench))
		buf.WriteString(fmt.Sprintf("Average Off-Target Count: %.1f\n", avgOffTarget))

		if len(guides) > 0 {
			buf.WriteString(fmt.Sprintf("Target Region: %s:%d\n", guides[0].Chromosome, guides[0].Position))
			buf.WriteString(fmt.Sprintf("Enzyme: %s\n", guides[0].Enzyme))
		}
	}
	buf.WriteString("\n")

	// Top guides
	buf.WriteString("TOP RANKED GUIDES\n")
	buf.WriteString("───────────────────────────────────────────────────────────────\n\n")

	for i, guide := range guides {
		if i >= 10 {
			break // Show top 10
		}

		buf.WriteString(fmt.Sprintf("GUIDE #%d (Rank Score: %.3f)\n", i+1, guide.RankScore))
		buf.WriteString(fmt.Sprintf("  Sequence:       5'-%s-%s-3'\n", guide.Sequence, guide.PAMSequence))
		buf.WriteString(fmt.Sprintf("  Location:       %s:%d (%s)\n", guide.Chromosome, guide.Position, guide.Strand))
		buf.WriteString(fmt.Sprintf("  Doench Score:   %.3f (%s)\n",
			guide.DoenchScore, e.getEfficiencyLabel(guide.DoenchScore)))
		buf.WriteString(fmt.Sprintf("  Off-Targets:    %d (Specificity: %.1f)\n",
			guide.OffTargetCount, guide.OffTargetScore))
		buf.WriteString(fmt.Sprintf("  GC Content:     %.1f%%\n", guide.GCContent))

		// Visual representation of scores
		buf.WriteString("  Scores:         ")
		buf.WriteString(e.makeScoreBar("Efficiency", guide.DoenchScore))
		buf.WriteString("\n                  ")
		buf.WriteString(e.makeScoreBar("Specificity", guide.OffTargetScore/100.0))
		buf.WriteString("\n\n")
	}

	// Recommendations
	buf.WriteString("RECOMMENDATIONS\n")
	buf.WriteString("───────────────────────────────────────────────────────────────\n")
	buf.WriteString("1. Validate top 3-5 guides experimentally\n")
	buf.WriteString("2. Consider ordering synthetic guides from IDT or Genscript\n")
	buf.WriteString("3. Clone guides into expression vector (e.g., lentiCRISPRv2)\n")
	buf.WriteString("4. Perform off-target validation with GUIDE-seq or CIRCLE-seq\n")
	buf.WriteString("5. Test in relevant cell line before in vivo experiments\n\n")

	buf.WriteString("═══════════════════════════════════════════════════════════════\n")
	buf.WriteString("End of Report\n")
	buf.WriteString("═══════════════════════════════════════════════════════════════\n")

	return buf.Bytes(), nil
}

// ExportJSON exports guides as JSON
func (e *Exporter) ExportJSON(guides []GuideRNA) ([]byte, error) {
	// Would use encoding/json in production
	var buf bytes.Buffer

	buf.WriteString("{\n")
	buf.WriteString("  \"guides\": [\n")

	for i, guide := range guides {
		buf.WriteString("    {\n")
		buf.WriteString(fmt.Sprintf("      \"id\": \"%s\",\n", guide.ID))
		buf.WriteString(fmt.Sprintf("      \"sequence\": \"%s\",\n", guide.Sequence))
		buf.WriteString(fmt.Sprintf("      \"chromosome\": \"%s\",\n", guide.Chromosome))
		buf.WriteString(fmt.Sprintf("      \"position\": %d,\n", guide.Position))
		buf.WriteString(fmt.Sprintf("      \"strand\": \"%s\",\n", guide.Strand))
		buf.WriteString(fmt.Sprintf("      \"pam_sequence\": \"%s\",\n", guide.PAMSequence))
		buf.WriteString(fmt.Sprintf("      \"doench_score\": %.3f,\n", guide.DoenchScore))
		buf.WriteString(fmt.Sprintf("      \"off_target_count\": %d,\n", guide.OffTargetCount))
		buf.WriteString(fmt.Sprintf("      \"off_target_score\": %.2f,\n", guide.OffTargetScore))
		buf.WriteString(fmt.Sprintf("      \"rank_score\": %.3f\n", guide.RankScore))

		if i < len(guides)-1 {
			buf.WriteString("    },\n")
		} else {
			buf.WriteString("    }\n")
		}
	}

	buf.WriteString("  ]\n")
	buf.WriteString("}\n")

	return buf.Bytes(), nil
}

// getEfficiencyLabel returns a human-readable efficiency label
func (e *Exporter) getEfficiencyLabel(score float64) string {
	if score >= 0.7 {
		return "High"
	} else if score >= 0.4 {
		return "Medium"
	} else if score >= 0.2 {
		return "Low"
	}
	return "Very Low"
}

// makeScoreBar creates a visual score bar
func (e *Exporter) makeScoreBar(label string, score float64) string {
	barLength := 20
	filled := int(score * float64(barLength))
	if filled > barLength {
		filled = barLength
	}

	bar := strings.Repeat("█", filled) + strings.Repeat("░", barLength-filled)
	return fmt.Sprintf("%s [%s] %.0f%%", label, bar, score*100)
}

// ExportToFile helper for writing to file system
func (e *Exporter) ExportToFile(guides []GuideRNA, format ExportFormat, filename string) error {
	req := ExportRequest{
		Guides: guides,
		Format: format,
	}

	data, err := e.Export(req)
	if err != nil {
		return err
	}

	// In production, would write to file
	_ = data
	_ = filename

	return nil
}
